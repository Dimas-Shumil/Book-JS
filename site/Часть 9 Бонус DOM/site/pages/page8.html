<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/sass.css">
    <title>Бонус DOM</title>
</head>

<body>
    <header class="header">
        <nav class="header__nav">

            <div class="header__nav-title">
                8.Работа с событиями
            </div>

            <ul class="header__nav-ul">
                <li><a href="../../index.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page2.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page3.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page4.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page5.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page6.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page7.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="#"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page9.html"><span class="header__nav-ul_link"></span></a></li>
            </ul>
        </nav>
    </header>
    <hr class="hr">
    </div>

    <div class="main">
        <div class="main__wrapper">
            <div id="mySidenav" class="sidenav">
                <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
                <a href="../../../Часть 1 Введение в JavScript/index.html" target="_blank"> Часть 1 Введение в JavScript</a>
                <a href="../../../Часть 2 Введение в JavaScript/index.html" target="_blank">Часть 2 Введение в JavaScript</a>
                <a href="../../../Часть 3 Введение в JavaScript/index.html" target="_blank">Часть 3 Введение в JavaScript</a>
                <a href="../../../Часть 4 Функции JavaScript/index.html" target="_blank">Часть 4 Функции JavaScript</a>
                <a href="../../../часть 5 Функции и объекты JavaScript/index.html" target="_blank">часть 5 Функции и объекты JavaScript</a>
                <a href="../../../часть 6 JavaScript  Объекты/index.html" target="_blank">часть 6 JavaScript Объекты</a>
                <a href="../../../Часть 7 JavaScript DOM/index.html" target="_blank">Часть 7 JavaScript DOM</a>
                <a href="../../../Часть 8 Бонус Ассинхронное программирование JavaScript/index.html" target="_blank">Часть 8 Бонус Ассинхронное программирование JavaScript</a>
                <a href="#">Часть 9 Бонус DOM</a>
                <a href="../../../Часть 10 AJAX/index.html" target="_blank">Часть 10 AJAX</a>
                <a href="../../../Часть11 API браузера/index.html" target="_blank">Часть11 API браузера</a>
                <a href="../../../Часть 12 Тестирование JS/index.html" target="_blank">Часть 12 Тестирование JS</a>
            </div>
            <span class="sidenav__btn" onclick="openNav()">&#9776;</span>
            <!-- <span class="sidenav__btn" style="font-size:30px;cursor:pointer; border: 1px solid grey;" onclick="openNav()">&#9776; Открыть</span> -->

            <div class="main__wrapper-conteiner">
                <p>В этом юните мы поговорим про события в браузере: какие они бывают, чем друг от друга отличаются и
                    как их поймать. Поехали!</p>
                <p>Многие современные сайты выглядят стильно, живо и динамично. Допустим, вы разработчик в Skillfactory.
                </p>
                <p>Посмотрим на сайт. Ваша задача — настроить модальное окно с чатом поддержки так, чтобы оно появлялось
                    по клику на кнопку.</p>
                <p>Эта кнопка в самом нижнем углу справа.</p>
                <figure>
                    <img src="../images/asset-v1_SkillFactory+INTFR+2023+type@asset+block@INTFR_10_13.png" width="100%"
                        alt="">
                    <figcaption>Сайт Skillfactory.ru</figcaption>
                </figure>
                <figure>
                    <img src="../images/asset-v1_SkillFactory+INTFR+2023+type@asset+block@INTFR_10_17.png" width="100%"
                        alt="">
                    <figcaption>Чат с техподдержкой SkillFactory</figcaption>
                </figure>
                <p>Итак, давайте разберёмся, как это сделать. Сначала о логике.</p>
                <p>Происходит следующее: вы нажимаете на кнопку, браузер вас понимает, открывает окошко. И теперь туда
                    можно писать. И нажимать уже другие кнопки: выбрать смайлик, прикрепить изображение, закрыть чат.
                </p>
                <p>Это сложный механизм, в котором вы должны связать HTML-разметку, CSS-стили и JS-код. Например, при
                    нажатии на кнопку появляется HTML-элемент с чатом. И появляется не абы как, а с CSS-анимацией. А
                    само нажатие было зафиксировано и обработано с помощью скрипта.</p>
                <hr class="hr">

                <h2>Упражнение 8.1</h2>
                <p>Итак, давайте сразу начнём с задачи. Выберите все инструменты, которые вам понадобятся, чтобы открыть
                    и закрыть окно с чатом.</p>
                <blockquote>Promise</blockquote>
                <blockquote>addEventListener <span class="green">&#10004;</span></blockquote>
                <blockquote>querySelector <span class="green">&#10004;</span></blockquote>
                <blockquote>методы свойства classList <span class="green">&#10004;</span></blockquote>
                <blockquote>fetch</blockquote>
                <hr class="hr">
                <p>Если вы определились с ответом, то давайте попробуем сделать простой аналог такого чата. И заодно
                    проверим ваши ответы.</p>
                <iframe src="../frame/frame8-1.html" width="100%" height="350px" frameborder="0"></iframe>
                <p>Итак, правильный ответ: addEventListener, querySelector и методы свойства classList.</p>
                <p>Разберём логику примера. У нас есть кнопка, при нажатии на которую мы вешаем класс на чат и он
                    появляется из ниоткуда. Значение его свойства display изменилось с none на flex.</p>
                <p>В самом чате есть вторая кнопка — крестик для закрытия. Если нажать на него, то чат снова исчезнет,
                    так как с него будет снят класс active. А display снова окажется равен none.</p>
                <p>Видите, как ловко мы связали HTML, CSS и JS? Магия, не иначе.</p>
                <p>Но что мы все о кликах да о кликах, разве нет других событий? Есть и много. Пользователи не только
                    кликают по кнопкам.</p>
                <p>Они ещё скроллят страницу, записывают что-то в поля ввода, наводят мышкой на ссылки. Всё это нужно
                    отслеживать разработчику. И на основе событий стилизовать и менять страницу.</p>
                <p>Поэтому настало время положить в свой багаж новые навыки.</p>
                <p>Для начала давайте введём четкое определение браузерному событию.</p>
                <h3>Браузерное событие — это сигнал, который ловит браузер при каких-то действиях пользователя на
                    странице. Клик мышкой, нажатие кнопки, скролл страницы, наведение курсора — всё это события. Браузер
                    оповещает разработчика, что событие произошло, а разработчик что-то с этой информацией делает.</h3>
                <p>Вы уже знаете и умеете вешать слушатели на элементы, разбираетесь в синтаксисе. Но всё же посмотрим
                    на него ещё разок:</p>
                <div class="main__wrapper-box_grey">
                    <p>element.addEventListener('click', function () {</p>
                    <blockquote>console.log('Случился клик!')</blockquote>
                    <p>})</p>
                </div>
                <p>Логика проста:</p>
                <blockquote>1. Определяем элемент, на который нужно повесить слушатель.</blockquote>
                <blockquote>2. Задаём метод addEventListener на этом элементе.</blockquote>
                <blockquote>3. Определяем тип слушателя.</blockquote>
                <blockquote>4. Передаём вторым аргументом функцию с логикой, которая выполнится при клике.</blockquote>
                <p>Готово! Но единственный ли это способ повесить слушатель на элемент? Нет, не единственный. Есть ещё и
                    второй.</p>

                <h2>on-свойства</h2>
                <p>Возможно, вы помните, что в объекте каждого DOM-элемента очень много свойств. В том числе — onclick,
                    onscroll, onsubmit и так далее. Проверим?</p>
                <figure>
                    <img src="../images/asset-v1_SkillFactory+INTFR+2023+type@asset+block@INTFR_10_2.png" width="100%"
                        alt="">
                    <figcaption>Свойства HTML-элемента</figcaption>
                </figure>
                <p>На этой картинке дефолтные свойства обычного div-а, который мы вывели в консоль с помощью
                    console.dir. Много свойств. Очень много. Все не влезли.</p>
                <p>Если присвоить в одно из них функцию с какой-то логикой, то она выполнится при срабатывании этого
                    события. То есть, если в onclick присвоить функцию, то при клике она отработает.</p>
                <iframe src="../frame/frame8-2.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>Проверим на практике. В примере две кнопки. Одна работает через привычный слушатель. А вторая — через
                    свойство onclick.</p>
                <p>Понажимайте обе кнопки и убедитесь, что всё работает корректно.</p>

                <h2>Упражнение 8.2</h2>

                <p>Есть событие mouseover. Оно — аналог hover в СSS. Когда пользователь наводит мышкой на элемент, то
                    происходит именно это событие. Напишите логику, которая отработает при наведении мышки на вторую
                    кнопку. Эту логику нужно присвоить свойству. Не используйте addEventListener.</p>
                <hr class="hr">

                <h2>Упражнение 8.3</h2>
                <p>Выберите on-свойство, которого не существует:</p>
                <blockquote>onerror</blockquote>
                <blockquote>ondom &#10004;</blockquote>
                <blockquote>onreset</blockquote>
                <blockquote>oncancel</blockquote>
                <hr class="hr">

                <h2>input и change</h2>

                <p>Вы наверняка часто что-то вводите в поля ввода. Например, когда ищете что-то в поисковике.
                    Задумывались, как работают подсказки для поиска? Мы ведь ещё не нажали ни на какую кнопку, а только
                    ввели две буквы? Что за магия?</p>
                <p>Никакой магии. Для этого есть событие input.</p>
                <iframe src="../frame/frame8-3.html" width="100%" height="300px" frameborder="0"></iframe>

                <p>Начните вводить сообщение в инпут. Каждая буква тут же добавится в параграф под полем ввода.</p>
                <p>Мы сделали это с помощью свойства oninput и функции, которая получает значение инпута через event.
                </p>
                <p>У event есть свойство target, которое хранит элемент, на котором совершилось событие. Поскольку у
                    инпута есть атрибут value, то мы можем его получить. А затем поместить в параграф.</p>

                <h2>Упражнение 8.4</h2>

                <p>Перепишите логику с помощью addEventListener. Помните, что название события — input.</p>
                <p>Есть и другой вариант, как получить значение из инпута. Однако логика немного отличается. Давайте
                    продублируем прошлый пример, но изменим событие.</p>

                <iframe src="../frame/frame8-4.html" width="100%" height="300px" frameborder="0"></iframe>

                <p>Снова начните вводить сообщение. Параграф останется пустым.</p>
                <p>Попробуйте нажать вне инпута, убрать с него фокус. В этот момент появится текст.</p>
                <p>Такое поведение удобно, если вы не хотите получать значение каждой введённой буквы. Например, при
                    валидации поля. Вы вводите какой-то текст, переходите к следующему полю ввода. В это время
                    полученное из инпута значение валидируется, и если с ним что-то не так, над инпутом высвечивается
                    надпись: значение некорректно.</p>
                <hr class="hr">

                <h2>Упражнение 8.5</h2>

                <p>Напишите код для этой ситуации. Проверяйте значение по длине строки. Если строка короче 8 символов,
                    то выведите предупреждение о некорректном значении. Если больше — то о том, что значение корректно.
                </p>
                <p>Стилизуйте инпут в соответствии с ситуацией. Например, красный бордер для некорректного значения и
                    зелёный для корректного.</p>

                <h2>submit</h2>

                <p>Все мы хоть раз где-то регистрировались. Вводили логин, пароль, почту. А затем нажимали на кнопку,
                    данные куда-то там улетали — или не улетали, если с ними что-то не так.</p>
                <p>Как работает такая отправка? Например, с помощью события submit.</p>
                <iframe src="../frame/frame8-5.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>Введите какие-нибудь данные в инпуты и нажмите на кнопку. На странице появится сообщение о том, что
                    вы вошли в аккаунт.</p>
                <p>Так сработало событие submit, которое произошло на форме. Обратите внимание на код — мы повесили
                    слушатель именно на форму.</p>
                <p>Это сделано, например, для того, чтобы не пропустить отправку формы при нажатии кнопки enter.</p>
                <hr class="hr">

                <h2>Упражнение 8.6</h2>
                <p>Перепишите код и замените слушатель на свойство onsubmit.</p>

                <h2>keydown</h2>
                <p>Иногда нет возможности нажать на что-то мышкой. В доступе только клавиатура. Чтобы что-то закрыть —
                    можно нажать кнопку Escape. Но как браузер понимает, чего мы от него хотим? Он отслеживает событие
                    keydown.</p>
                <iframe src="../frame/frame8-6.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>Мы создали простое модальное окно, которое открывается по нажатию на кнопку. А вот закрыть его можно
                    только нажатием на кнопку Escape. Попробуйте сами.</p>
                <p>Лёгким движением руки модальное окно исчезает.</p>
                <p>Посмотрите внимательнее на то, как мы этого добились:</p>
                <div class="main__wrapper-box_grey">
                    <p>document.addEventListener("keydown", (event) => {</p>
                    <blockquote>if (event.key === "Escape") {
                        <blockquote>popup.style.display = "none";</blockquote>
                        }
                    </blockquote>
                    <p>});</p>
                </div>
                <p>Мы повесили слушатель не на какой-то конкретный элемент, не на кнопку и не на попап. А на весь
                    документ. Теперь браузер следит за документом, и если срабатывает нажатие на кнопку, то запускается
                    функция.</p>
                <p>Эта функция проверяет, что за кнопка была нажата. И снова нам пришёл на помощь объект event. Мы
                    обратились к свойству key и узнали, какое ключевое слово зарезервировано за нажатой кнопкой.</p>
                <p>Нас интересовала только кнопка Escape. Так и пишем.</p>
                <p>Если проверка прошла успешна, закрываем попап. В ином случае окно так и останется висеть на странице.
                </p>
                <hr class="hr">

                <h2>Упражнение 8.7</h2>
                <p>Поменяйте кнопку с Escape на любую другую. Чтобы узнать ключевое слово нужной кнопки, воспользуйтесь
                    списком на EyeHunts.</p>

                <h2>scroll</h2>
                <p>Видели когда-нибудь, как при скролле страницы в углу появлялись стрелочки? Например, чтобы вернуться
                    на самый верх сайта или прокрутить до конца.</p>
                <p>Давайте реализуем что-то подобное с помощью события scroll.</p>
                <iframe src="../frame/frame8-7.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>В этом примере мы повесили событие scroll на window. И если пользователь начинает скроллить страницу,
                    то запускается логика появления и исчезновения кнопок.</p>
                <p>Мы использовали много новых инструментов. Давайте их разберём:</p>
                <h3>
                    <p>pageYOffset — свойство, которое возвращает число, на которое прокручено окно window.</p>
                    <p>offsetHeight — отдаёт высоту элемента с паддингами, скроллбарами и бордерами.</p>
                    <p>scrollTo — метод, который прокручивает страницу до определенного значения.</p>
                </h3>
                <p>На стрелках есть события по прокручиванию страницы в нужное место. А внутри слушателя скролла —
                    логика по проверке, в каком месте находится пользователь.</p>
                <hr class="hr">

                <h2>Упражнение 8.8</h2>
                <p>Самостоятельно разберите логику этого примера. Проанализируйте, как работают новые свойства и методы.
                </p>
                <hr class="hr">

                <h2>DOMContentLoaded</h2>

                <p>Сейчас мы рассмотрим необычное событие. Оно не про клик мышкой или нажатие кнопки.</p>
                <h3>DOMContentLoaded — событие, которое срабатывает после того, как браузер создал DOM-дерево.</h3>
                <p>Для чего это нужно? Для того, чтобы запустить какую-то логику только тогда, когда все элементы уже
                    отрисованы. И не будет такого, что вы вешаете на узлы какие-то действия, а их ещё нет.</p>
                <p>Давайте посмотрим на примере.</p>
                <iframe src="../frame/frame8-8.html" width="100%" height="500px" frameborder="0"></iframe>
                <p>Он немного напоминает предыдущий модуль и асинхронные операции. 🙂</p>
                <p>Обратите внимание, что строка внутри обработчика отработала не второй, а последней. Всё потому, что
                    браузеру нужно время на разбор HTML и его парсинг в DOM-дерево.</p>

                <h2>Упражнение 8.9</h2>
                <p>Напишите логику, которая дожидается отрисовки дерева и задаёт картинке другой размер.</p>
                <hr class="hr">

                <h2>load и resize</h2>

                <p>Это событие похоже на предыдущее, но с нюансами.</p>
                <h3>load — событие, которое гарантирует не только уже отрисованное дерево, но и загрузку всех ресурсов
                    для этого дерева. Картинок, шрифтов, стилей и так далее.</h3>
                <p>Например, это событие отлично перехватывает момент, когда загрузилась нужная картинка. Очень полезный
                    функционал.</p>
                <p>Пример: вы написали логику для картинки, а её ещё нет в дереве. Итог: всё ломается.</p>
                <p>Давайте сделаем следующий финт. Помните, как мы отставили в сторону пример в предыдущем юните? Там,
                    где нужно скрывать меню, открывать кнопку и наоборот?</p>
                <p>Вернёмся и завершим его с помощью двух новых событий, resize и load.</p>
                <p>Напомним проблему. Стили применялись корректно ровно один раз, но при изменении окна всё ломалось.
                </p>
                <p>Теперь мы можем это поправить.</p>
                <iframe src="../frame/frame8-9.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>Подвигайте окно. Кнопка то появляется, то скрывается. То же самое происходит и с ссылками.</p>
                <p>Но есть одно но. Перезагрузите пример. Где кнопка? Где ссылки? Ничего нет. Наша логика появляется
                    только тогда, когда мы изменяем окно с помощью события resize. А вот по дефолту, без изменения
                    размера экрана ничего не происходит.</p>
                <p>Можно, конечно, продублировать эту логику перед блоком с событием. А можно положить эту логику в
                    событие load. И тогда проверка на размер экрана пройдёт ровно в тот момент, когда HTML и все ресурсы
                    для него будут загружены.</p>

                <h2>Упражнение 8.10</h2>
                <p>Напишите проверку размера экрана — но уже для события load. Попробуйте избежать дублирования кода.
                </p>
                <hr class="hr">

                <h2>Делегирование событий</h2>

                <p>Представим, что у нас есть товары в онлайн-магазине. У каждого кнопка добавления в корзину. При
                    нажатии на эту кнопку счетчик товаров становится больше на единицу. И эта цифра обновляется на
                    иконке корзины.</p>
                <p>Как задать всем кнопкам такую логику?</p>
                <p>Выбрать все элементы с классом кнопки, перебрать их циклом, а затем повесить нужный слушатель.</p>
                <p>Так, а если товаров очень много? А если они подгружаются постепенно? Каждый раз получать всё новые и
                    новые товары и бесконечно вешать события?</p>
                <p>Можно и по-другому. Например, делегировать событие на document.</p>
                <iframe src="../frame/frame8-10.html" width="100%" height="500px" frameborder="0"></iframe>
                <p>Здесь мы повесили слушатель на document, и теперь при клике логика внутри делает простую проверку.
                    Во-первых, есть ли целевой элемент, на котором произошло событие. Во-вторых, есть ли у него нужный
                    нам класс. Если да, то счётчик увеличивается, значение в шапке меняется. И не нужно вешать никаких
                    событий на каждую кнопку. А если вдруг подгрузятся новые товары с такими же кнопками, то событие
                    отработает и на них. Несмотря на то, что они появились позже.</p>

                <h2>Упражнение 8.11</h2>
                <p>Добавьте логику добавления новых товаров. Например, по кнопке. Убедитесь, что событие увеличения
                    счётчика сработает и на них.</p>

                <h2>removeEventListener</h2>

                <p>Завершим наш долгий путь очень важным методом. Удалением слушателей событий.</p>
                <p>Зачем это нужно? Затем, что любая логика занимает память. Не вопрос, если вам эта логика очень нужна.
                    А если она становится ненужной? В этом случае она просто занимает место.</p>
                <p>Также старые слушатели могут конфликтовать с новыми — это тоже неприятно.</p>
                <p>Поэтому давайте научимся их удалять.</p>
                <iframe src="../frame/frame8-11.html" width="100%" height="350px" frameborder="0"></iframe>
                <p>Здесь у нас две кнопки. Первая выводит предупреждение, что кнопка нажата. Вторая — удаляет эту логику
                    с первой кнопки и выводит сообщение об этом в консоль.</p>
                <p>Понажимайте на первую кнопку, а затем на вторую. После этого alert уже не будет работать.</p>
                <p>Давайте поговорим об одном нюансе. Вы наверняка помните, что функции — это ссылки. Даже если две
                    функции содержат идентичную логику, это будут две разных функции.</p>
                <p>Поэтому в нашем примере мы создаём именные функции и именно их передаём в качестве хэндлеров в
                    addEventListener и removeEventListener. Нам нужно добавлять и удалять одну и ту же функцию. Это
                    очень важно.</p>

                <h2>Упражнение 8.12</h2>
                <p>Попробуйте убрать именные функции в примере и заменить их на обычные коллбэки в виде () => {}.
                    Проанализируйте результат.</p>
                <p>Поздравляю, вы завершили все юниты этого модуля! Теперь в вашем арсенале ещё больше полезных
                    инструментов и фундаментальных знаний. Вы:</p>
                <blockquote>Узнали, какие ещё события бывают: change, input, submit и так далее.</blockquote>
                <blockquote>Поработали с аналогом addEventListener — on-свойствами.</blockquote>
                <blockquote>Научились удалять слушатели с элементов.</blockquote>
                <hr class="hr">

                <h2>Упражнение 8.13</h2>

                <p>Создайте форму с несколькими инпутами. Напишите логику по валидации результатов этих инпутов. Правила
                    валидации придумайте самостоятельно: длина строки, наличие каких-то символов или чисел и так далее.
                </p>
                <blockquote>
                    <details>
                        <summary><a href="https://codepen.io/SkillFactory/pen/dyQaNKR?editors=1111"><span class="green">
                                    Решение</span></a></summary>
                    </details>
                </blockquote>
                <hr class="hr">

                <h2>Упражнение 8.14</h2>

                <p>Сделайте галерею с картинками, которые можно постепенно подгружать. У каждой картинки должна быть кнопка «Нравится». Дизайн на ваш вкус: SVG, стилизованные псевдоэлементы или просто надпись. При нажатии на эту кнопку стили картинки и самой кнопки меняются. Используйте делегирование событий.</p>
                <blockquote>
                    <details>
                        <summary><a href="https://codepen.io/SkillFactory/pen/RwqvKJx?editors=1010"><span class="green">
                                    Решение</span></a></summary>
                    </details>
                </blockquote>
                <hr class="hr">

                <h2>Упражнение 8.15</h2>

                <p>Напишите название события, которое срабатывает при каждой введённой в поле ввода букве:</p>
                <blockquote> input <span class="green">	&#10004;</span></blockquote>
                <hr class="hr">

                <h2>Упражнение 8.16</h2>

                <p>Напишите код счётчика. Начальное значение — 0. Максимальное значение — 42. Увеличивается число при нажатии на кнопку. Как только это число достигнуто, покажите кнопку сброса счётчика. Чтобы не дать числу выйти за рамки значений, воспользуйтесь removeEventListener.</p>
                <blockquote>
                    <details>
                        <summary><a href="https://codepen.io/SkillFactory/pen/abQXpjZ"><span class="green">
                                    Решение</span></a></summary>
                    </details>
                </blockquote>
                <hr class="hr">
            </div>
            <!-- кнопки -->
            <div class="main__btn-box">
                <a href="page7.html" class="previous">&laquo; Назад</a>
                <a href="page9.html" class="next">Вперед &raquo;</a>
            </div>
            <div class="main__btn-box-o">
                <a href="page7.html" class="previous round">&#8249;</a>
                <a href="page9.html" class="next round">&#8250;</a>
            </div>
        </div>

        <button onclick="topFunction()" id="myBtn" title="Перейти к началу">вверх</button>

        <script async src="../script/js.js"></script>

        <!-- &lsaquo;&rsaquo;&lsaquo;/&rsaquo;
             &lsaquo;script&rsaquo;&lsaquo;/script&rsaquo; -->
        <!-- <details>
            <summary>Заголовок</summary>
            Здесь располагается скрытый контент, который будет отображен после клика по заголовку.
        </details>
    </div>
</body>

</html>