<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/sass.css">
    <title>Тестирование</title>
</head>

<body>
    <header class="header">
        <nav class="header__nav">
            <div class="header__nav-title">
                4. Пирамида тестирования
            </div>
            <ul class="header__nav-ul">
                <li><a href="../../index.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page2.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page3.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="#"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page5.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page6.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page7.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page8.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page9.html"><span class="header__nav-ul_link"></span></a></li>
            </ul>
        </nav>
    </header>
    <hr class="hr">
    </div>
    <div class="main">
        <div class="main__wrapper">
            <div id="mySidenav" class="sidenav">
                <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
                <a href="#" target="_blank"> Часть 1 Введение в JavScript</a>
                <a href="#">Часть 2 Введение в JavaScript</a>
                <a href="#">Часть 3 Введение в JavaScript</a>
                <a href="#">Часть 4 Функции JavaScript</a>
                <a href="#">часть 5 Функции и объекты JavaScript</a>
                <a href="#">часть 6 JavaScript Объекты</a>
                <a href="#">Часть 7 JavaScript DOM</a>
                <a href="#">Часть 8 Бонус Ассинхронное программирование JavaScript</a>
                <a href="#">Часть 9 Бонус DOM</a>
                <a href="#">Часть 10 AJAX</a>
                <a href="#">Часть 12 Тестирование JS</a>
                <a href="#">Часть11 API браузера</a>
            </div>
            <span class="sidenav__btn" onclick="openNav()">&#9776;</span>
            <div class="main__wrapper-conteiner">
                <p>Существует ключевая концепция, которая позволяет описать структуру автоматизированных тестов для всего приложения — так называемая <span class="green"> пирамида тестирования.</span></p>
                <figure>
                    <img src="../images/m16_pyramid.png" width="45%" alt="">
                </figure>
                <p>При написании набора тестов для всего приложения, принято руководствоваться принципами, отраженными в данной пирамиде: необходимо писать тесты для разных уровней детализации и обращать внимание на количество — чем меньше уровень детализации и больше затронутых подсистем, тем меньше тестов.</p>
                <p>Пирамида делит тесты на три уровня: юнит тесты, интеграционные и сквозные.</p>
                <ol>
                    <li>
                        <span class="green"> Юнит тесты</span> (<i>unit tests</i>, модульное тестирование). К данной группе относятся тесты, которые предназначены для проверки отдельных частей программы — юнитов (функций, компонентов, модулей). Юнит тесты обычно пишут разработчики. Такие тесты являются самыми быстродействующими, «дешевыми» (самыми быстрыми и легковесными) и простыми в реализации.
                        <p>Хорошая структура тестов:</p>
                        <ol>
                            <li>Настройка тестовых данных.</li>
                            <li>Вызов тестируемого метода.</li>
                            <li>Проверка, что возвращаются ожидаемые результаты.</li>
                        </ol>
                        <p>С понятием юнит-тестов связаны два определения — <span class="green"> имитации</span> (<i>mocks</i>) и <span class="green"> заглушки</span> (<i>stubs</i>). Это так называемые тестовые дублеры (их существует гораздо больше). Иногда эти термины используют в контексте друг друга (иногда могут быть взаимозаменяемы). Разница этих понятий в том, что stub — не имитирует вообще ничего, то есть это может быть noop (анонимная функция) либо null вместо объекта, когда важен сам факт наличия аргумента . Mocks же несут в себе некоторую информацию. Что использовать, нужно решать по факту написания теста, опираясь на его цель.</p>
                        <div class="main__wrapper-box_grey">
                            <h2>Как это работает?</h2>
                            <p>Вы заменяете реальную вещь (например, класс, модуль или функцию) поддельной копией. Подделка выглядит и действует как оригинал (даёт такие же ответы на те же вызовы методов), но это заранее установленные ответы, которые вы сами определяете для юнит-теста.</p>
                        </div>
                        <p>Тестовые дублёры используются не только в юнит-тестах. Более сложные дублёры применяются для контролируемой имитации целых частей вашей системы. Однако в юнит-тестах используется особенно много имитаций и заглушек просто потому что множество современных языков и библиотек позволяют легко и удобно их создавать.</p>
                        <div class="main__wrapper-box_pink">
                            <p>Примеры инструментов: <i>jest, karma, mocha</i></p>
                        </div>
                    </li>
                    <li>
                        <span class="green"> Интеграционные тесты</span> (<i>Integration tests</i>). Реализованные модули приложения обычно является частью системы, в которую они будут внедряться. Интеграционные тесты призваны проверить работоспособность модулей приложения при работе в комплексе. Данные тесты являются более сложными и медленными, однако дают уверенность в работе всего приложения.
                        <p>То есть приложения интегрированы с некоторыми другими частями (базы данных, файловые системы, сетевые вызовы к другим приложениям). В юнит-тестах такое поведение обычно имитируется для лучшей изоляции и повышения скорости. Тем не менее, в случае, если приложение будет реально взаимодействовать с другими частями — это следует протестировать. Для этого предназначены интеграционные тесты. Они проверяют взаимодействие приложения со всеми компонентами вне этого приложения.</p>
                        <div class="main__wrapper-box_grey">
                            <h2>Как это работает?</h2>
                            <p>Нужно запустить не только собственное приложение, но и интегрируемый компонент. Если вы тестируете интеграцию с БД, то при выполнении тестов надо запустить БД. Чтобы проверить чтение файлов с диска, нужно сохранить файл на диск и загрузить его в интеграционный тест.</p>
                        </div>
                        <p>В пирамиде интеграционные тесты находятся на более высоком уровне, чем модульные. Интеграция файловых систем и БД обычно гораздо медленнее, чем выполнение юнит-тестов с их имитациями. Их также труднее писать, чем маленькие изолированные модульные тесты. В конце концов, нужно думать о работе внешней части теста. Тем не менее, они имеют преимущество, потому что дают уверенность в правильной работе приложения со всеми внешними частями, с какими нужно. Юнит-тесты тут бесполезны.</p>
                        <div class="main__wrapper-box_pink">

                            <p>Примеры инструментов: <i>cucumber, protractor, nightwatch</i></p>
                        </div>
                    </li>
                    <li>
                        <span class="green"> Сквозные тесты</span> (<i>End-to-End</i>) предназначены для проверки приложения в целом. Они охватывают проверку его работоспособности при взаимодействии со всеми вовлеченными системами и фактически отражают то, насколько приложение готово к работе.
                        <p>Иногда говорят, что сквозные тесты и тесты UI (user interface)— это одно и то же. По сути, можно считать и так.</p>
                        <p>Тестирование приложения от начала до конца часто означает прохождение через пользовательский интерфейс. Но обратное неверно. Тестирование пользовательского интерфейса необязательно должно проводиться в сквозном режиме. В зависимости от используемой технологии, тестирование UI может быть довольно простым.</p>
                        <p>Тестирование развёрнутого приложения через UI — это самый полный тест, какой только можно провести.</p>
                        <div class="main__wrapper-box_grey">
                            <p>Сквозные тесты известны своей ненадёжностью, сбоями по неожиданным и непредвиденным причинам. Довольно часто это ложноположительные сбои. Чем более сложный UI, тем более хрупкими становятся тесты. Причуды браузера, проблемы с синхронизацией, анимация и неожиданные всплывающие диалоги — лишь некоторые из причин, из-за которых тратится больше времени на отладку, чем хотелось бы.</p>
                        </div>
                        <p>Кроме того, сквозные тесты выполняются довольно медленно. Если в приложении много микросервисов, то нет даже шансов запускать сквозные тесты локально, потому что тогда понадобится и все микросервисы запускать локально. Это как попытка запустить сотни приложений на персональном компьютере — вряд ли ему хватит мощностей.</p>
                        <p>Из-за высоких расходов на обслуживание следует свести число сквозных тестов к абсолютному минимуму. И если они все таки нужны, то выбрать правильный инструмент и научиться им пользоваться.</p>
                        <div class="main__wrapper-box_pink">
                            <p>Примеры инструментов: <i>Selenium, Cypress</i></p>
                        </div>
                    </li>
                </ol>
                <hr class="hr">
                <p>Опыт эксперта:</p>
                <div class="main__wrapper-box_grey">
                    <h2>Наталья Крестинина — преподаватель и эксперт курса «Frontend-разработчик», разработчик в EPAM-systems:</h2>
                    <figure>
                        <img src="../images/m16_Natalia_expert.jpg" width="50%" alt="">
                    </figure>
                    <p><i>«У меня был опыт внедрения unit-тестов в уже готовый проект. Оказалось, что 8 из 20 утилитных функций по работе с датами и математическими операциями работают неправильно в ситуациях, которые называются corner cases».</i></p>
                </div>
                <hr class="hr">
                <h2>Задание 11.4.2</h2>
                <p>Вам поручили протестировать работу системы электронного документооборота компании, в которую впервые интегрированны сторонние онлайн-сервисы: мессенджер для общения сотрудников и база знаний.</p>
                <blockquote>Интеграционное тестирование</blockquote>
            </div>

            <!-- кнопки -->
            <div class="main__btn-box">
                <a href="page3.html" class="previous">&laquo; Назад</a>
                <a href="page5.html" class="next">Вперед &raquo;</a>
            </div>
            <div class="main__btn-box-o">
                <a href="page3.html" class="previous round">&#8249;</a>
                <a href="page5.html" class="next round">&#8250;</a>
            </div>
        </div>

        <button onclick="topFunction()" id="myBtn" title="Перейти к началу">вверх</button>

        <script async src="../script/js.js"></script>

        <!-- &lsaquo;&rsaquo;&lsaquo;/&rsaquo;
             &lsaquo;script&rsaquo;&lsaquo;/script&rsaquo; -->
        <!-- <details>
            <summary>Заголовок</summary>
            Здесь располагается скрытый контент, который будет отображен после клика по заголовку.
        </details>
    </div>
</body>

</html>