<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/sass.css">
    <title>Бонус. Асинхронное программирование JS</title>
</head>

<body>
    <header class="header">
        <nav class="header__nav">

            <div class="header__nav-title">
                2. Введение в асинхронное программирование на JS
            </div>

            <ul class="header__nav-ul">
                <li><a href="../../index.html" class="header__nav-ul_link"></span></a></li>
                <li><a href="#"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page3.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page4.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page5.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page6.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page7.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page8.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page9.html"><span class="header__nav-ul_link"></span></a></li>
            </ul>
        </nav>
    </header>
    <hr class="hr">
    </div>

    <div class="main">
        <div class="main__wrapper">
            <div id="mySidenav" class="sidenav">
                <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
                <a href="../../../Часть 1 Введение в JavScript/index.html" target="_blank"> Часть 1 Введение в JavScript</a>
                <a href="../../../Часть 2 Введение в JavaScript/index.html" target="_blank">Часть 2 Введение в JavaScript</a>
                <a href="../../../Часть 3 Введение в JavaScript/index.html" target="_blank">Часть 3 Введение в JavaScript</a>
                <a href="../../../Часть 4 Функции JavaScript/index.html" target="_blank">Часть 4 Функции JavaScript</a>
                <a href="../../../часть 5 Функции и объекты JavaScript/index.html" target="_blank">часть 5 Функции и объекты JavaScript</a>
                <a href="../../../часть 6 JavaScript  Объекты/index.html" target="_blank">часть 6 JavaScript Объекты</a>
                <a href="../../../Часть 7 JavaScript DOM/index.html" target="_blank">Часть 7 JavaScript DOM</a>
                <a href="#">Часть 8 Бонус Ассинхронное программирование JavaScript</a>
                <a href="../../../Часть 9 Бонус DOM/index.html" target="_blank">Часть 9 Бонус DOM</a>
                <a href="../../../Часть 10 AJAX/index.html" target="_blank">Часть 10 AJAX</a>
                <a href="../../../Часть11 API браузера/index.html" target="_blank">Часть11 API браузера</a>
                <a href="../../../Часть 12 Тестирование JS/index.html" target="_blank">Часть 12 Тестирование JS</a>
            </div>
            <span class="sidenav__btn" onclick="openNav()">&#9776;</span>
            <!-- <span class="sidenav__btn" style="font-size:30px;cursor:pointer; border: 1px solid grey;" onclick="openNav()">&#9776; Открыть</span> -->

            <div class="main__wrapper-conteiner">

                <hr class="hr">

                <p>В этом юните мы поговорим о том, что такое асинхронное программирование. Вы узнаете, почему этот
                    инструмент очень важен для современной разработки. Изучите основные термины и погрузитесь в теорию
                    асинхронного кода.</p>
                <p>До этого вы практиковались в синхронном коде. В предыдущем модуле мы говорили о циклах, о функциях и
                    их аргументах. И код, который вы писали, –– был синхронным. То есть, вот таким:</p>

                <div class="main__wrapper-box_grey">
                    <p>function nameConsoler() {</p>
                    <blockquote>console.log('Вася здесь!');</blockquote>
                    <blockquote>console.log('Петя тоже.');</blockquote>
                    <blockquote>console.log('И Миша на месте.');</blockquote>
                    <p>}</p>
                </div>
                <p>Если вызвать такую функцию, то в консоли появится предсказуемый результат:</p>
                <p>Вася здесь!</p>
                <p>Петя тоже.</p>
                <p>И Миша на месте.</p>
                <p>Код отработал в том порядке, в котором мы его написали. Здесь всё понятно. Никаких сюрпризов. Почему
                    так:</p>

                <div class="main__wrapper-box_blue">
                    <p>JavaScript — однопоточный язык программирования.</p>
                    <p>Представьте ленту с багажом. Если лента одна, то чемоданы и сумки появляются на ленте по одной
                        штуке. Один за другим. Если нарушить этот порядок, то выход для багажа забьется, начнутся хаос и
                        неразбериха.</p>
                    <p>Синхронный JS-код работает так же. Задачи выполняются одна за одной.</p>
                    <p>Мы поговорим про однопоточность подробнее в конце юнита.</p>
                </div>

                <p>Представим, что вы печёте блины. Выложили все продукты на стол: яйца, молоко, муку, сахар и соль.
                    Осталось только в нужном порядке всё положить в тарелку, перемешать — и готово.</p>
                <p>Давайте представим эту аналогию в виде функции.</p>

                <div class="main__wrapper-border_green">
                    <p><b>Примечание</b></p>
                    <p>Помните, что это — псевдокод. Мы опустили создание функции <span
                            class="blue">addIngredient</span> и переменных с продуктами, чтобы не тратить на это слишком
                        много времени.</p>
                </div>

                <div class="main__wrapper-box_grey">
                    <p>function <span class="green">pancakeMaker()</span> {</p>
                    <blockquote>console.log('Добро пожаловать в “Едим не Дома”! Сегодня мы готовим блины!')</blockquote>
                    <blockquote><span class="green"> addIngredient</span>(egg);</blockquote>
                    <blockquote><span class="green"> addIngredient</span>(sugar);</blockquote>
                    <blockquote><span class="green"> addIngredient</span>(salt);</blockquote>
                    <blockquote><span class="green"> addIngredient</span>(milk);</blockquote>
                    <blockquote><span class="green"> addIngredient</span>(flour);</blockquote>
                    <blockquote><span class="green"> addIngredient</span>(oil);</blockquote>
                    <blockquote><span class="green"> mixAll</span>();</blockquote>
                    <blockquote>console. <span class="red">log</span>('Готово! Вы восхитительны!')</blockquote>
                    <p>}</p>
                </div>

                <p>Мы добавили по очереди все продукты, а потом смешали их в чашке с помощью функции mixAll(). Всё
                    последовательно, никаких задержек, никаких сложностей.</p>
                <p>Но всё меняется, когда мы начинаем их жарить. Набирать в половник тесто, наливать в сковороду. Ждать,
                    пока блинчик будет готов с одной стороны, потом с другой.</p>
                <p>Если мы будем по старой памяти всё делать последовательно, без задержек, то запахнет жареным.</p>
                <p>Нельзя без пауз наливать тесто, тут же его переворачивать, тут же снимать с огня и наливать новый
                    блин. Так что же делать?</p>
                <p>Давайте напишем функцию так, чтобы паузы между действиями были учтены.</p>
                <p>Рассмотрим старый добрый codepen для наглядности.</p>

                <div class="main__wrapper-box_grey">
                    <p>function <span class="green"> pancakeBaker</span>() {</p>
                    <blockquote>console.log(<span class="red">"Тесто готово, давайте жарить!"</span>);</blockquote>
                    <blockquote>console.log(<span class="red">"Наливаем тесто для одного блинчика."</span>);
                    </blockquote>
                    <p>setTimeout(() => {</p>
                    <blockquote>console.log(<span class="red">"Перевернём блин на другую сторону и подождём
                            ещё."</span>);</blockquote>
                    <p>setTimeout(() => {</p>
                    <blockquote>console.log(<span class="red">"Блинчик готов!"</span>);</blockquote>
                    <blockquote> }, 5000);</blockquote>
                    <p> }, 5000);</p>
                    <p> console.log(<span class="red">'Пока постоим и подождём.'</span>)</p>
                    <p>}</p>
                    <p>// pancakeBaker();</p>
                </div>

                <p>Раскомментируйте вызов функции pancakeBaker и посмотрите в консоль. Понаблюдайте, в какой
                    последовательности выводятся строчки.</p>

                <div class="main__wrapper-box_blue">
                    <p>Пока что вы не знакомы с функцией setTimeout(). Ничего страшного, можете пока просто понаблюдать
                        за ней, за тем, как она устроена. В дальнейшем вы научитесь с ней работать.</p>
                    <p>Сейчас главное — понять, почему синхронное программирование не сможет решить все задачи. И затем
                        мы начнём разбирать асинхронное программирование.</p>
                </div>

                <p>В консоли вы можете увидеть, что первые три строки появляются сразу, друг за другом.</p>

                <div class="main__wrapper-box_grey">
                    <p>function <span class="red"><b>pancakeBaker</b></span>() {</p>
                    <p>// первая строчка</p>
                    <blockquote><span class="red"> console.</span><span class="red"><b>log</b></span>(<span
                            class="red">"Тесто готово, давайте жарить!"</span>);</blockquote>
                    <blockquote>// вторая строчка</blockquote>
                    <blockquote><span class="red"> console.</span><span class="red"><b>log</b></span>(<span
                            class="red">"Наливаем тесто для одного блинчика."</span>);</blockquote>
                    <blockquote>
                        <blockquote> … асинхронная логика …</blockquote>
                    </blockquote>
                    <p>// третья строчка</p>
                    <blockquote><span class="red"> console.</span><span class="red"><b>log</b></span>(<span
                            class="red">'Пока постоим и подождём.'</span>);</blockquote>
                    <p>}</p>
                </div>

                <p>Это — синхронный код. И он выполнился последовательно, друг за другом. Такое мы уже делали, тут
                    разбирать нечего.</p>
                <p>Но после третьей строчки в консоли происходит первая задержка. Разберём её подробнее.</p>

                <div class="main__wrapper-box_grey">
                    <p><span class="green"> setTimeout</span>(() => {</p>
                    <blockquote><span class="red"> console.</span><span class="red"><b>log</b></span>(<span
                            class="red">"Перевернём блин на другую сторону и подождём ещё."</span>);</blockquote>
                    <p>}, 5000);</p>
                </div>

                <p>Эта задержка сделана благодаря функции setTimeout. Воспринимайте её как таймер на телефоне или на
                    компьютере.</p>
                <p>Если поставить таймер на 5 секунд, то по истечении этого времени заиграет мелодия. И эта мелодия
                    похожа на строку console.log(‘Перевернём блин…’).</p>
                <p>В чем схожесть? В логике. Эта строка окажется в консоли по истечении 5000 миллисекунд так же, как
                    музыка зазвучит по истечении заданного времени.</p>
                <p>Итак, что мы сделали. Мы использовали асинхронную функцию и отложили выполнение кода на время. А пока
                    этот код отложился, выполнились синхронные кусочки кода.</p>
                <p>То же самое произошло и со вторым отложенным кодом:</p>

                <div class="main__wrapper-box_grey">
                    <p><span class="green"> setTimeout</span>(() => {</p>
                    <blockquote><span class="red"> console.</span><span class="red"><b>log</b></span>(<span
                            class="red">"Блинчик готов!"</span>);</blockquote>
                    <p>}, 5000);</p>
                </div>

                <p>Эта строчка появилась в консоли ещё через 5 секунд.</p>

                <h2>Упражнение* 2.1</h2>

                <p>Это задание со звёздочкой.</p>
                <blockquote>Попробуйте сделать так, чтобы между выводом строчки «Наливаем тесто…» и «Пока постоим и
                    подождём» была пауза в 2 секунды. Используйте setTimeout. Ориентируйтесь на код в примере.
                </blockquote>
                <blockquote>
                    <details>
                        <summary><span class="green"> Посмотреть код</span></summary>
                        <div class="main__wrapper-box_grey">
                            <p>function <span class="red"><b>pancakeBaker</b></span>() {</p>
                            <blockquote><span class="red"> console.</span><span class="red"><b>log</b></span>(<span
                                    class="red">"Тесто готово, давайте жарить!"</span>);</blockquote>
                            <blockquote><span class="red">console. <b>blog</b></span>(<span class="red">"Наливаем тесто
                                    для одного
                                    блинчика."</span>);</blockquote>
                            <blockquote><span class="green">setTimeout</span>(() => {</blockquote>
                            <blockquote>
                                <blockquote><span class="red">console. <b>log</b></span>(<span class="red">"Перевернём
                                        блин на другую
                                        сторону и подождём ещё."</span>);</blockquote>
                            </blockquote>
                            <blockquote><span class="green">setTimeout</span>(() => {</blockquote>
                            <blockquote>
                                <blockquote><span class="red">console. <b>log</b></span>(<span class="red">"Блинчик
                                        готов!"</span>);</blockquote>
                            </blockquote>
                            <blockquote>},<span class="red">5000</span>);</blockquote>
                            <p>},<span class="red">5000</span>);</p>
                            <blockquote><span class="green">setTimeout</span>(() => {</blockquote>
                            <blockquote>
                                <blockquote><span class="red">console. <b>log</b></span>(<span class="red">'Пока постоим
                                        и подождём.'</span>);</blockquote>
                            </blockquote>
                            <blockquote>},<span class="red">2000</span>);</blockquote>
                            <p>}</p>
                        </div>
                    </details>
                </blockquote>

                <span class="red"></span>

                <h2>Проблемы, которые решает асинхронное программирование</h2>

                <p>Так какую же проблему решает асинхронный код?</p>
                <p>В наших примерах синхронного кода задачи выполнялись очень быстро. Строчки моментально выводились в
                    консоль и не блокировали остальную работу.</p>
                <p>Но вы наверняка знаете, что этим разработка не ограничивается. Давайте представим социальную сеть, в
                    которой пользователи выкладывают свои фотографии и тексты.</p>
                <p>Вы хотите зайти на профиль знакомого. Посмотреть, что нового случилось в его жизни за последнюю
                    неделю. Предполагаю, что вы привыкли к быстрой загрузке сайта, в которой ничего не виснет и все
                    данные подгружаются почти мгновенно.</p>
                <p>Если бы этот сайт был написан только синхронным кодом, то вместо удобного интерфейса и постепенно
                    появляющихся картинок и постов вы бы смотрели на зависший сайт. А потом, возможно, получили бы вот
                    такую прелесть:</p>

                <figure>
                    <img src="../images/INTFR_9_2_1 (1).png" width="50%" alt="">
                </figure>

                <p>Асинхронный код помогает этого не допустить. Вы загружаете страницу сайта. Запрос данных с сервера не
                    блокирует всё остальное, и вы можете пользоваться сайтом дальше. А когда данные придут, вы их
                    увидите и узнаете, как там поживал ваш друг.</p>
                <p>Сформулируем проблему, которую решает асинхронный подход:</p>

                <div class="main__wrapper-box_blue">
                    <p>Асинхронный подход оптимизирует работу кода, не позволяет длительным операциям блокировать работу
                        других задач и сохраняет интерфейс отзывчивым.</p>
                </div>

                <p>Ещё раз проговорим разницу между синхронным и асинхронным программированием:</p>

                <h3>Синхронное программирование — это когда мы вызываем функцию и сразу получаем её результат. И пока
                    результат не получен, следующая в очереди функция ждёт пока выполнится предыдущая.</h3>
                <h3>Асинхронное программирование — это когда мы вызываем функцию, но получаем результат не сразу, а
                    через какое-то время. При этом выполнение этой функции не блокирует другие задачи в потоке. И
                    программа продолжает работать, а не зависает в ожидании, пока результат появится.</h3>
                <hr class="hr">
            </div>

            <p>Упражнение 2.2</p>

            <p><b>правильные утверждения про асинхронный код:</b></p>
            <blockquote>Асинхронный код позволяет нескольким задачам выполняться параллельно.</blockquote>
            <blockquote>Результат в асинхронных функциях доступен не сразу.</blockquote>
            <hr class="hr">

            <div class="main__wrapper-conteiner">
                <h2>Однопоточность</h2>

                <p>Задачи понятны, проблемы понятны. Но если JS — однопоточная лента для багажа, каким образом
                    асинхронный код работает? Благодаря чему? Настало время заглянуть под капот JavaScript. Пристегните
                    ремни.</p>
                <p>Есть пять важных элементов:</p>
                <p>1. Global Memory (Heap) — глобальная память или «куча». Место, где JS хранит объекты.</p>
                <p>2. Call Stack — стек вызовов. Он хранит контекст выполнения функций и её локальные переменные.</p>
                <p>3. Callback Queue — очередь колбэков.</p>
                <p>4.Web API — API браузера.</p>
                <p>Event Loop — цикл событий.</p>
                <p>Посмотрим на схему:</p>

                <figure>
                    <iframe src="../images/shsrnsrjnsrn/index.html" width="60%" height="500px" frameborder="0"></iframe>
                </figure>
                <p>
                    Не пугайтесь, если что-то не понимаете. Сейчас разберём каждый элемент подробнее.</p>

                <h2>Куча глобальной памяти</h2>

                <p>Вы уже создавали объекты и объявляли функции. А потом выводили какие-то данные в консоль. Например,
                    ключи этих объектов или результат выполнения функций.</p>
                <p>Но где это всё хранится? Почему вы можете достучаться до этих данных и прочитать их значения?</p>
                <p>У JavaScript под капотом есть глобальная память:</p>

                <h3>
                    <p>Глобальная память или куча (heap) — это место, где хранятся объекты и функции. У кучи нет лимита
                        по объёму. И нет структуры. На то она и куча.</p>
                    <p>Если программе нужно больше места, то куча обязательно его выделит. Это — динамическое выделение
                        памяти.</p>
                </h3>

                <p>Почему в куче хранятся только объекты? Потому что их размер может динамически меняться. Например, вы
                    можете объявить массив, а потом добавлять в него элементы. И тогда его размер увеличится.</p>
                <p>Если бы в куче были ограничения на размер, то сделать это было бы сложно.</p>
                <p>Представьте комнату, в которой творческий беспорядок. В одном углу могут соседствовать сапоги для
                    рыбалки, мольберт и три носка. В другом — банка с клубничным вареньем, учебник по японскому языку и
                    пальто из 90-х с широкими плечами.</p>
                <p>Натуральная куча. Для всего есть место, можно даже принести что-нибудь ещё и кинуть в третий угол. Но
                    порядка никакого. Зато много что помещается.</p>
                <hr class="hr">
            </div>

            <p>Упражнение 2.3</p>

            <p>Выберите верные утверждения:</p>
            <blockquote>У кучи нет структуры, данные хранятся в ней в произвольном порядке.</blockquote>
            <blockquote>В куче хранятся объекты, массивы и функции.</blockquote>
            <hr class="hr">

            <div class="main__wrapper-conteiner">
                <h2>Стек вызовов</h2>

                <p>Мы уже поняли, что JS берёт наши объекты и функции и уносит их в кучу. А куда тогда девать примитивы:
                    строки, числа, булевые значения?</p>
                <p>Для этого есть другая структура данных — стек.</p>
                <h3>Стек отслеживает выполнение функций в вашем коде. Он не может быть больше положенного. Данные в нём
                    имеют фиксированный размер.</h3>
                <p>Метафора стека: чемодан. Как бы вам ни хотелось вместить в него все вещи при переезде, у вас не
                    получится.</p>
                <p>У каждой вещи есть фиксированный размер, у чемодана — тоже. Если есть что-то лишнее — убираем. Нужное
                    — кладём. Более того. Чтобы что-то достать снизу, придётся сначала выложить всё, что сверху.</p>
                <p>Чемодан — эталонный стек.</p>
                <p>Как вы помните, JavaScript — однопоточный. И делает только одну задачу за раз. А когда закончит —
                    перейдёт к другой.</p>
                <p>Поэтому каждый раз, когда вы вызываете функцию в JavaScript, её вызов оказывается на вершине стека. А
                    когда выполнение окончено, функция удаляется. Выглядит это примерно так:</p>

                <figure>
                    <img src="../images/INTFR_9_2_3.gif" width="90%" alt="">
                    <p>Визуализация стека вызовов. Источник: <a href="https://simonzhlx.github.io/js-engine/"><span
                                class="green"> https://simonzhlx.github.io/js-engine</span></a></p>
                </figure>
                <p>Про стек важно знать следующее:</p>
                <div class="main__wrapper-box_blue">
                    <p>Он работает по несправедливому принципу: чем раньше ты пришёл, тем позже уйдешь.</p>
                </div>

                <p>Если бы очереди к врачу работали по такому принципу, вселенная бы, наверное, схлопнулась.</p>
                <p>Представить стек можно на примере стопки с книгами. Предположим, что вы разбираете домашнюю
                    библиотеку и кладёте книги друг на друга. Вторую на первую, третью на вторую — и так далее.</p>
                <p>Такая стопка — тот же стек. Чтобы взять первую книгу из стопки, лучше снять перед этим все верхние.
                    Можно, конечно, попытаться её выдернуть из-под всех остальных. Но, поверьте, не стоит. Скорее всего,
                    ваша башня из книг разрушится.</p>
                <p>Давайте напишем код, чтобы посмотреть, как всё это работает в действии:</p>

                <iframe src="../frame/frame2/index.html" width="90%" height="350px" frameborder="0"></iframe>

                <p>Понаблюдайте, как хитро мы расположили вызовы функций.</p>
                <p>Первой вызывается thirdFunction, она попадает в стек вызовов в первую очередь. Затем на неё падает
                    secondFunction, так как именно её мы вызываем во вторую очередь внутри функции thirdFunction. И уже
                    в последнюю очередь в стек попадает сама firstFunction, так как мы вызвали её в конце.</p>
                <p>И они отработали, как и ожидалось. Последний пришёл — первый ушёл, первый пришёл — последний ушёл.
                </p>
                <p>Третья функция не могла быть удалена из стека, пока первая функция не отработала и не смогла
                    произвести вычисления и вернуть результат.</p>

                <h2>Упражнение 2.4</h2>

                <p>Добавьте в последний пример по аналогии четвёртую функцию, которая бы вызывалась первее всех и
                    уходила из стека позднее всех. Эта функция должна вызывать третью функцию.</p>
                <blockquote>
                    <details>
                        <summary>Посмотреть код</summary>
                        <div class="main__wrapper-box_grey">
                            <p>const firstFunction = (num) => {</p>
                            <blockquote>console.log(`Первая функция работает, аргумент равен ${num}`);</blockquote>
                            <p>};</p>
                            <p>const secondFunction = (num) => {</p>
                            <blockquote>console.log("Вторая функция работает");</blockquote>
                            <blockquote>return firstFunction(num);</blockquote>
                            <p>};</p>
                            <p>const thirdFunction = (num) => {</p>
                            <blockquote>console.log("Третья функция работает");</blockquote>
                            <blockquote>return secondFunction(num);</blockquote>
                            <p>};</p>
                            <p>const fourthFunction = (num) => {</p>
                            <blockquote>console.log("Четвертая функция работает");</blockquote>
                            <blockquote>return thirdFunction(num);</blockquote>
                            <p>};</p>
                            <p>fourthFunction(3);</p>
                        </div>
                    </details>
                </blockquote>

                <p>Теперь мы знаем о том, как работает выполнение функций. Одна за одной, друг за другом. Поэтому у вас
                    должен возникнуть справедливый вопрос.</p>
                <p>А что, если не все функции такие же шустрые, как в нашем примере?</p>
                <p>Представьте, что в функции заложены длительные сложные операции на 20 секунд. Если бы код был
                    синхронным, вам бы пришлось занять себя на эти 20 секунд.
                </p>
                <p>Изучать потолок, поставить чайник, просто упорно смотреть в монитор и ждать. А потом уже продолжать
                    работать с сайтом.</p>
                <p>Но в реальных проектах такого не происходит. И это не значит, что в них нет сложных операций и все
                    задачи синхронные. Тогда в чём секрет?</p>
                <p>Продолжим двигаться в сторону разгадки.</p>
                <hr class="hr">
            </div>

            <p>Упражнение 2.5</p>

            <p>верные утверждения о стеке.</p>
            <blockquote>Стек следит за выполнением функций.</blockquote>
            <hr class="hr">

            <div class="main__wrapper-conteiner">

                <h2>Web API</h2>

                <p>Всё ещё непонятно, как же работает асинхронность. Мы знаем про многие элементы под капотом. Но не
                    хватает кусочка пазла. Это — API браузера.</p>
                <p>Остановимся. И обсудим API как абстракцию.</p>
                <h3>API — Application Programming Interface — это инструмент, свод правил, который позволяет разным
                    программам друг с другом работать.</h3>
                <p>Допустим, вы пришли в кафе. Вы знаете, что у вас есть следующие опции:</p>
                <p> &bull; Получить меню;</p>
                <p> &bull; Заказать блюдо;</p>
                <p> &bull; Попросить счёт;</p>
                <p> &bull; Попросить воды.</p>
                <p>Меню состоит из списка блюд в определённом формате. У каждого есть картинка, список ингредиентов,
                    цена и граммовка.</p>
                <p>У вас, как у посетителя, тоже есть свой API:</p>
                <p>&bull; </p>
                <p>&bull; </p>
                <p>&bull; </p>
                <p>У вас можно принять заказ и получить его в формате списка блюд и каких-то пожеланий;</p>
                <p>Узнать метод оплаты, который вы будете использовать;</p>
                <p>Попросить не курить в зале</p>
                <p>И так далее. Это очень упрощённый образ. Конечно, настоящий API сложнее. Но попробуйте вникнуть в
                    концепцию. Это вам очень поможет. 🙂</p>
                <p>Браузерный API включает много пунктов. Нас интересуют следующие</p>
                <p>&bull; setTimeout, setInterval;</p>
                <p>&bull; HTTP-запросы на сервер;</p>
                <p>&bull; DOM (Document Object Model) — инструмент для работы с HTML и СSS.</p>
                <p>Мы будем подробно изучать эти пункты позднее. Пока что поговорим про идею, без тонкостей.</p>
                <p>Что происходит, когда вы пишете асинхронную функцию и кладёте туда коллбэк? Например, через
                    setTimeout? JS не становится вдруг многопоточным. Однако и работа других задач не блокируется. Как?
                </p>
                <p>Посмотрим на картинку:</p>

                <figure>
                    <img src="../images/INTFR_9_2_4 (1).gif" width="90%" alt="">
                    <p>Визуализация Event Loop. Источник: <a href="https://simonzhlx.github.io/js-engine/"><span
                                class="green"> https://simonzhlx.github.io/js-engine</span></a></p>
                </figure>
                <p>Что здесь происходит? SetTimeout летит в блок с Web API, а после этого функция внутри таймаута
                    попадает в очередь коллбэков.</p>

                <h2>Очередь коллбэков</h2>

                <p>На всякий случай вспомним:</p>

                <h3>Коллбэк или обратный вызов — это функция, которая передаётся в другую функцию. Коллбэки выполняются
                    не сразу, а в момент, когда родительская функция завершит какую-то операцию или достигнет какого-то
                    состояния.</h3>
                <p>Если есть коллбэки, значит, их тоже надо где-то хранить, правильно? Да. Для этого существует очередь
                    коллбэков.</p>
                <h3>Очередь коллбэков — это очередь, в которую попадает коллбэк после того, как регистрируется. Важно
                    то, что очередь работает по принципу FIFO (First In First Out). То есть: если коллбэк добавился в
                    конец и перед ним ещё три функции, то он будет ждать их выполнения и только после этого отработает
                    сам.</h3>
                <p>Вернёмся к Web API. Именно API браузера разбирается с асинхронными функциями, освобождает JS и
                    позволяет ему продолжать исполнять синхронные задачи. Он ждёт выполнения операций и в конце посылает
                    коллбэк в очередь.</p>
                <p>Как только стек вызовов пустеет, то коллбэки из этой очереди выполняются. Заметьте, что теперь это
                    уже не несправедливый стек, где ты приходишь раньше, а уходишь позже. Теперь это дефолтная очередь к
                    врачу, и всё происходит по совести. Первый пришёл, первый ушёл.</p>

                <div class="main__wrapper-box_blue">
                    <p>Очень важно запомнить: что задачи в очереди обратных вызовов выполняются только после того, как
                        стек вызовов пуст. Не раньше. Сами задачи из очереди тоже делятся на группы, которые имеют
                        разный приоритет.</p>
                </div>
                <p>Браузерный API — это местный менеджер. И JS делегирует ему свои задачи, чтобы не выгореть и не уехать
                    в ретрит на Бали раньше времени.</p>

                <h2>Цикл событий</h2>

                <p>Итак, мы подошли вплотную к тому, почему асинхронное программирование работает. Что связывает
                    коллбэки, стек вызовов и браузерный API?</p>
                <p>Event loop, цикл событий. Именно он, как самый главный босс, следит за всем и поддерживает работу
                    кода.</p>
                <h3>Event Loop — это бесконечный цикл, который работает с событиями. Он наблюдает за стеком вызовов,
                    очередью коллбэков и выполняет их, когда они появляются. Важно понимать, что event loop — не часть
                    JS. Он является частью браузера.</h3>
                <p>На картинке выше вы уже могли увидеть event loop в самом центре. Это сердце асинхронного
                    программирования.</p>
                <p>Он находится в бесконечном ожидании задач, следит за очередью и стеком и выполняет наш код.</p>
                <p>Благодаря его работе мы можем делать классные приложения и сайты, со сложными анимациями и большим
                    количеством данных с сервера.</p>
                <p>В следующих юнитах мы разберём работу цикла событий более подробно, когда изучим микротаски и
                    макротаски.</p>
                <p>А пока — первый юнит подошёл к концу. Вы, как и планировалось, погрузились в фундаментальные идеи
                    асинхронного программирования. Поняли, как работает JavaScript под капотом и какие инструменты он
                    использует для работы.</p>
                <p>Теперь вы ещё ближе к тому, чтобы стать крутым профессионалом! :)</p>
                <hr class="hr">
            </div>

            <p>Упражнение 2.6</p>

            <p><b>Что выведется в консоль?</b></p>
            <div class="main__wrapper-box_grey">
                <p>const foo1 = (a) => {</p>
                <blockquote>let b = a * a</blockquote>
                <blockquote>console.log(b)</blockquote>
                <p>}</p>

                <p>const foo2 = (c) => {</p>
                <blockquote>let c = b * 2</blockquote>
                <blockquote>foo1(c)</blockquote>

                <p>const foo3 = (d) => {</p>
                <blockquote>let f = d + 4</blockquote>
                <blockquote>foo2(f)</blockquote>
                <p>}</p>
                <p>foo3(4)</p>
            </div>
            <blockquote><b>256</b></blockquote>
            </p>
            <hr class="hr">

            <p>Упражнение 2.7</p>

            <p><b>В какой последовательности функции из предыдущего кода окажутся в стеке?</b></p>
            <blockquote>foo3, foo2, foo1</blockquote>
            <hr class="hr">

            <div class="main__wrapper-conteiner">
                <h2>Упражнение 2.8</h2>

                <p>Напишите функцию, которая принимает аргументом число n. Если это число равно 0, то функция пишет в
                    консоль: «Функция завершена!»</p>
                <p>Если нет, то вычитает из числа n единицу, снова вызывает саму себя и передаёт аргументом новое число
                    n.</p>

                <details>
                    <summary>Посмотреть код</summary>
                    <div class="main__wrapper-box_grey">
                        <p>const counter = (n) => {</p>
                        <blockquote>if (n===0) {</blockquote>
                        <blockquote>
                            <blockquote>console.log("Операция завершена")</blockquote>
                        </blockquote>
                        <blockquote>} else {</blockquote>
                        <blockquote>
                            <blockquote>counter (n - 1);</blockquote>
                        </blockquote>
                        <blockquote>}</blockquote>
                        <p>};</p>
                    </div>
                </details>
            </div>
            <!-- кнопки -->
            <div class="main__btn-box">
                <a href="../../index.html" class="previous">&laquo; Назад</a>
                <a href="page3.html" class="next">Вперед &raquo;</a>
            </div>
            <div class="main__btn-box-o">
                <a href="../../index.html" class="previous round">&#8249;</a>
                <a href="page3.html" class="next round">&#8250;</a>
            </div>
        </div>

        <button onclick="topFunction()" id="myBtn" title="Перейти к началу">вверх</button>

        <script async src="../script/js.js"></script>

        <!-- &lsaquo;&rsaquo;&lsaquo;/&rsaquo;
             &lsaquo;script&rsaquo;&lsaquo;/script&rsaquo; -->
        <!-- <details>
            <summary>Заголовок</summary>
            Здесь располагается скрытый контент, который будет отображен после клика по заголовку.
        </details>
    </div>
</body>

</html>