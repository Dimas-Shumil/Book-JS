<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/sass.css">
    <title>Бонус DOM</title>
</head>

<body>
    <header class="header">
        <nav class="header__nav">

            <div class="header__nav-title">
                7. Работа с размером
            </div>

            <ul class="header__nav-ul">
                <li><a href="../../index.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page2.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page3.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page4.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page5.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page6.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="#"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page8.html"><span class="header__nav-ul_link"></span></a></li>
                <li><a href="page9.html"><span class="header__nav-ul_link"></span></a></li>
            </ul>
        </nav>
    </header>
    <hr class="hr">
    </div>

    <div class="main">
        <div class="main__wrapper">
            <div id="mySidenav" class="sidenav">
                <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
                <a href="../../../Часть 1 Введение в JavScript/index.html" target="_blank"> Часть 1 Введение в JavScript</a>
                <a href="../../../Часть 2 Введение в JavaScript/index.html" target="_blank">Часть 2 Введение в JavaScript</a>
                <a href="../../../Часть 3 Введение в JavaScript/index.html" target="_blank">Часть 3 Введение в JavaScript</a>
                <a href="../../../Часть 4 Функции JavaScript/index.html" target="_blank">Часть 4 Функции JavaScript</a>
                <a href="../../../часть 5 Функции и объекты JavaScript/index.html" target="_blank">часть 5 Функции и объекты JavaScript</a>
                <a href="../../../часть 6 JavaScript  Объекты/index.html" target="_blank">часть 6 JavaScript Объекты</a>
                <a href="../../../Часть 7 JavaScript DOM/index.html" target="_blank">Часть 7 JavaScript DOM</a>
                <a href="../../../Часть 8 Бонус Ассинхронное программирование JavaScript/index.html" target="_blank">Часть 8 Бонус Ассинхронное программирование JavaScript</a>
                <a href="#">Часть 9 Бонус DOM</a>
                <a href="../../../Часть 10 AJAX/index.html" target="_blank">Часть 10 AJAX</a>
                <a href="../../../Часть11 API браузера/index.html" target="_blank">Часть11 API браузера</a>
                <a href="../../../Часть 12 Тестирование JS/index.html" target="_blank">Часть 12 Тестирование JS</a>
            </div>
            <span class="sidenav__btn" onclick="openNav()">&#9776;</span>
            <!-- <span class="sidenav__btn" style="font-size:30px;cursor:pointer; border: 1px solid grey;" onclick="openNav()">&#9776; Открыть</span> -->

            <div class="main__wrapper-conteiner">
                <p>Помните, мы обсуждали, что HTML-блоки похожи на кубики? Нам, как разработчикам и пользователям
                    сайтов, очень важны их размеры.</p>
                <p>Картинки должны быть не слишком большие и не слишком маленькие. Пользователь хочет успешно попадать
                    по кнопкам, а не пытаться попасть.</p>
                <p>А ещё хочется быть в курсе, какого размера экран пользователя. Какая ширина, высота и так далее. Ведь
                    если вы знаете такие вещи, то можете более гибко настраивать свой сайт под пользователя.</p>
                <p>А значит — не упускать потенциальных клиентов и располагать их к дальнейшему пользованию.</p>
                <p>Поэтому седьмой юнит мы посвятим размерам элементов. А точнее методам и свойствам, с помощью которых
                    этими размерами можно управлять.</p>
                <p>Начнём с размера экрана.</p>

                <h2>window.innerWidth и window.outerWidth</h2>

                <p>Поговорим сразу о двух свойствах.</p>
                <h3>
                    <p>window.innerWidth возвращает ширину той области, которую видит пользователь. То есть то, что
                        внутри окна, с горизонтальной прокруткой. Если вы измените размер окна, то это значение тоже
                        поменяется.</p>
                    <p>window.outerWidth возвращает полную ширину браузера вместе со элементами интерфейса.</p>
                </h3>
                <p>Давайте рассмотрим это на живом браузере.</p>
                <p>Перед вами картинка, на которой браузер открыт на всю ширину — 1440px. В консоли вы видите, что
                    innerWidth и outerWidth — идентичны. Неудивительно, ведь никаких дополнительных элементов интерфейса
                    не открыто.</p>
                <figure>
                    <img src="../images/asset-v1_SkillFactory+INTFR+2023+type@asset+block@INTFR_10_9.png" width="90%"
                        alt="">
                    <figcaption>Ситуация, где window.innerWidth и window.outerWidth одинаковы</figcaption>
                </figure>
                <p>А теперь попробуем подключить какой-нибудь браузерный элемент. Например, боковую панель.</p>
                <figure>
                    <img src="../images/asset-v1_SkillFactory+INTFR+2023+type@asset+block@INTFR_10_14.png" width="90%"
                        alt="">
                    <figcaption>Ситуация, где window.innerWidth и window.outerWidth разные</figcaption>
                </figure>
                <p>В этот раз внутренняя ширина окна и внешняя — разные. Так как ширина браузера всё ещё осталась равна
                    1440 пикселям, а вот вьюпорт, видимая область страницы — уменьшилась.</p>
                <p>Иногда нужно, чтобы какие-то элементы появлялись при одной ширине экрана, но исчезали при другой. Это
                    можно сделать с помощью смены классов.</p>
                <p>Давайте реализуем, что приходит на ум — мобильное меню.</p>
                <iframe src="../frame/frame7-1.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>Мы сделали простую проверку: больше ли 768 пикселей наше окно? Да — покажите меню, нет — покажите
                    мобильную кнопку.</p>
                <p>Так же, как через медиа-запросы, только с помощью JS. Зачем? Задачи нужно уметь решать разными
                    способами. Вдруг вы не можете изменять стили через CSS — остаётся работать со скриптом.</p>
                <p>Сейчас у нас есть проблема: проверка на ширину размера происходит один раз. Какой размер окна был на
                    момент отрисовки, те стили и применились.</p>
                <p>Если при загрузке окно codepen было меньше 768 пикселей, то меню скрыто, а кнопка-бургер на месте.
                    Если вы сделаете экран шире, кнопка не исчезнет, а ссылки навигации не появятся.</p>
                <p>Зафиксируйте сейчас этот момент. Мы вернёмся к решению проблемы в следующем юните. И настроим работу
                    проверки так, чтобы всё отображалось корректно.</p>

                <h2>Упражнение 7.1</h2>
                <p>Напишите логику, при которой шапка получает другие стили, если ширина экрана меньше 768 пикселей.
                    Используйте классы, свойство classList и window.innerWidth.</p>

                <h2>clientWidth и clientHeight</h2>

                <p>Эти два свойства возвращают ширину и высоту элемент без учёта скроллбара и бордера.</p>
                <iframe src="../frame/frame7-2.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>В примере мы создали два квадрата. Почти одинаковых. Ширина и высота у них — идентичные. Однако в 200
                    пикселей первого квадрата входит бордер. А у второго бордера нет.</p>
                <p>Как это повлияет на значение clientWidth и width из объекта DOMRect? Давайте посмотрим в консоль.</p>
                <p>У второго квадрата всё предсказуемо. Значение clientWidth и значение width одинаковы. Здесь никакой
                    загадки.</p>
                <p>А вот у первого квадрата значения разные. clientWidth первого квадрата — 192 пикселя. Без учета 8
                    пикселей, которые ушли на бордер.</p>
                <p>Запомните поведение этого значения. Иногда это может сэкономить вам время в поиске багов. 🙂</p>

                <h2>Упражнение 7.2</h2>
                <p>Проделайте подобные вычисления с clientHeight и height квадратов. Проанализируйте результаты.</p>
                <div class="main__wrapper-box_blue">
                    <p>Имейте в виду, что для инлайн-элементов clientWidth вернёт не ширину, а 0.</p>
                </div>

                <h2>getBoundingClientRect</h2>

                <p>Представьте страницу с сайтом как систему координат. Всё, что в ней находится, имеет свои размеры и
                    координаты.</p>
                <p>Их можно получить, что-то с ними делать, использовать в сложной логике.</p>
                <p>Это возможно благодаря методу getBoundingClientRect.</p>

                <h3>
                    <p>getBoundingClientRect — это метод, который возвращает объект с разными параметрами элемента.
                        Например:</p>
                    <blockquote>width — ширина.</blockquote>
                    <blockquote>height — высота.</blockquote>
                    <blockquote>Положение по оси X — начиная с левого верхнего угла документа.</blockquote>
                    <blockquote>Положение по оси Y — начиная с верха документа.</blockquote>
                    <blockquote>left — координата по оси X от начала до левой стороны элемента.</blockquote>
                    <blockquote>right — координата по оси X от начала до правой стороны элемента.</blockquote>
                    <blockquote>top — координата по оси Y от начала до верхней стороны элемента.</blockquote>
                    <blockquote>bottom — координата по оси Y от начала до нижней стороны элемента.</blockquote>
                </h3>
                <p>Синтаксис:</p>
                <div class="main__wrapper-box_grey">
                    <p>element.getBoundingClientRect()</p>
                </div>
                <p>element.getBoundingClientRect()</p>
                <figure>
                    <img src="../images/asset-v1_SkillFactory+INTFR+2023+type@asset+block@INTFR_10_16.png" width="90%"
                        alt="">
                    <figcaption>getBoundingClientRect</figcaption>
                    <figcaption>Источник: <a href="https://developer.mozilla.org/ru/"><span class="green">
                                developer.mozilla.org</span></a></figcaption>
                </figure>
                <p>Давайте создадим какой-нибудь элемент и получим его параметры.</p>
                <iframe src="../frame/frame7-3.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>В примере у нас небольшая заметка в блоге. Она помещена по центру.</p>
                <p>Мы получили этот элемент в коде, а затем присвоили в переменную rect объект с его размерами.</p>
                <p>Раскомментируйте последнюю строчку и посмотрите на него в консоли. Вам известна ширина, высота и
                    координаты элемента в пространстве.</p>
                <div class="main__wrapper-box_blue">
                    <p>Обратите внимание, что объект, который хранит эти значения, называется DOMRect. Это особый тип
                        объекта. Он хранит параметры области, которую занимает прямоугольник (rectangle) элемента.</p>
                </div>
                <p>Эти параметры вы можете использовать в сложных анимациях, когда нужно менять размер элемента или его
                    положение в пространстве.</p>

                <h2>Упражнение 7.3</h2>
                <p>Создайте элемент, который перекроет пост в примере, закроет его собой. Используйте абсолютное
                    позиционирование и параметры из DOMRect объекта.</p>
                <hr class="hr">

                <h2>Упражнение 7.4</h2>
                <p>Запишите строку, в которой получаете у элемента block его ширину. Используйте
                    getBoundingClientRect(). Помните, что вы можете обратиться к параметру сразу после объявления этого
                    метода в формате: элемент.метод().параметр.</p>
                <blockquote>block.getBoundingClientRect().width</blockquote>
                <hr class="hr">
                <p>Поговорим немного о свойствах X и Y. Если с шириной и высотой элемента всё понятно, то с координатами
                    нужно разобраться.</p>
                <p>В школе вы наверняка проходили системы координат. Высчитывали X и Y какой-нибудь точки.</p>
                <p>Наша ситуация похожа на школьные координаты, но есть некоторые различия. Давайте посмотрим на вот
                    такой визуальный пример:</p>
                <iframe src="../frame/frame7-4.html" width="100%" height="400px" frameborder="0"></iframe>
                <p>Мы сделали аналог браузерного окна. И визуально показали две системы координат:</p>
                <blockquote>&#10148; Браузерную — координаты считаются относительно окна.</blockquote>
                <blockquote>&#10148; Документную — координаты считаются относительно документа.</blockquote>
                <p>В браузере мы отобразили две картинки: капибару и таксу. У капибары — фиксированное позиционирование.
                    Поэтому её координаты относительно окна всегда одинаковы. Не важно, как долго и упорно вы скроллите
                    страницу. Капибара не сдвинется с места.</p>
                <p>А вот с таксой дела обстоят иначе. Она спозиционирована абсолютно. И двигается вместе с документом.
                </p>
                <p>Её координаты относительно документа не меняются. А вот относительно окна — ещё как. Ведь она уходит
                    за его границы — в отрицательные числа.</p>
                <p>Координаты от окна и координаты от документа — это две разные пары координат. И совпадают они лишь
                    тогда, когда документ прокручен в самое начало. Не путайте.</p>
                <p>Так какие же X и Y отдаёт нам getBoundingClientRect?</p>
                <p>Поработайте с этим вопросом самостоятельно, а затем мы раскроем эту тайну.</p>

                <h2>Упражнение 7.5</h2>
                <p>В последнем примере воспользуйтесь addEventListener и типом события «scroll». Повесьте его на window.
                    Это событие слушает, как вы скроллите страницу.</p>
                <p>Напишите внутри этого слушателя логику — получите DOMRect-объект и его свойство Y. Проанализируйте,
                    как меняется эта координата. И сделайте вывод, относительно чего отдаёт координаты
                    getBoundingClientRect.</p>
                <blockquote>
                    <details>
                        <summary>Показать ответ</summary>
                        <p>Правильный ответ — относительно окна. Поэтому координата Y нашего поста будет уменьшаться до
                            отрицательных чисел.</p>
                    </details>
                </blockquote>
                <p>Вы можете использовать такое поведение для того, чтобы прокручивать страницу до нужных элементов с
                    помощью JS.</p>

                <h2>pageX, clientX, pageY, clientY</h2>

                <p>Мы выяснили, что координаты относительно окна и относительно документа — это не одно и то же. Значит,
                    когда мы кликаем по какому-то месту, то координаты этого клика тоже разные.</p>
                <p>Эти значения полезны в том случае, если вы, например, хотите отследить, куда чаще всего жмут
                    пользователи и поместить туда рекламный баннер.</p>
                <div class="main__wrapper-box_blue">
                    <p>Чтобы получить координаты клика относительно документа, можно использовать pageX и pageY. А если
                        вы хотите увидеть координаты нажатия относительно окна — примените clientX или clientY.</p>
                </div>
                <iframe src="../frame/frame7-5.html" width="100%" height="300px" frameborder="0"></iframe>
                <p>Посмотрите на синтаксис в примере:</p>
                <div class="main__wrapper-box_grey">
                    <p>e.clientY, e.pageY</p>
                </div>
                <p>Помните e/event? Мы уже говорили о нём в прошлом модуле. Настало время к нему вернуться.</p>
                <p>Event содержит в себе много информации, полезной для разработки. Где кликнул пользователь, прокрутил
                    ли страницу до конца? Если вы знаете ответы на эти вопросы, то можете прокачивать эффективность
                    сайта.</p>
                <p>В этот раз мы воспользуемся этим и получим координаты клика через event. Кликните на страницу и
                    посмотрите в консоль. Если ещё не прокрутили страницу, то оба числа будут одинаковыми.</p>
                <p>Прокрутите страницу до середины или конца и снова нажмите куда-нибудь. Второе число теперь намного
                    больше первого.</p>
                <p>Первое свойство clientY отдаёт нам координату относительно окна. А pageY — относительно документа.
                    Это число могло бы помочь разработчику понять, дочитывают ли контент на его сайте до конца или юзеры
                    уходят со страницы раньше. Предупреждён — значит вооружён.</p>

                <h2>Упражнение 7.6</h2>
                <p>Поработайте с pageX и clientX. Увеличьте div так, чтобы у него появилась горизонтальная прокрутка.
                    Напишите логику, при которой в консоль будут выводиться координаты клика по оси X относительно окна
                    и относительно документа.</p>
                <p>Вы поработали с размерами элементов, узнали, как получать координаты элементов, и научились с ними
                    работать.</p>
                <p>В следующем юните мы подробнее разберём браузерные события и слушатели этих событий. До скорого!</p>
                <hr class="hr">

                <h2>Упражнение 7.7</h2>
                <p>Создайте разметку, в которой один div. Стилизуйте его: задайте определенную ширину и высоту. Затем
                    напишите логику, в которой вы получаете его размеры и из JS создаёте три таких же элемента с
                    идентичными размерами. Пользуйтесь свойством style.</p>
                <blockquote>
                    <a href="https://codepen.io/SkillFactory/pen/ExOrNqq"> <span class="green">Решение</span></a>
                </blockquote>
                <hr class="hr">

                <h2>Упражнение 7.8</h2>
                <p>Какое свойство вернёт координату клика относительно окна по оси Y?</p>
                <blockquote>ClientY <span class="green">&#10004;</span></blockquote>
                <hr class="hr">

                <h2>Упражнение 7.9</h2>
                <p>Создайте блок определённого размера и две кнопки. Одна кнопка должна получать ширину блока и увеличивать её на 10 пикселей при каждом клике. А вторая — уменьшать на те же 10 пикселей. Учитывайте ситуации, в которых ширина элемента достигла нуля либо максимальной ширины окна.</p>
                <blockquote>
                    <a href="https://codepen.io/SkillFactory/pen/vYQbgNg"> <span class="green">Решение</span></a>
                </blockquote>
                <hr class="hr">

                <h2>Упражнение 7.10</h2>
                <p>Создайте разметку с картинкой. Сделайте так, чтобы страницу можно было прокрутить — добавьте большое количество текста или задайте контейнеру с картинкой большую высоту. Когда картинка будет уходить за пределы окна, выводите предупреждение об этом.</p>
                <blockquote>
                    <a href="https://codepen.io/SkillFactory/pen/poQGRjQ"> <span class="green">Решение</span></a>
                </blockquote>
                <hr class="hr">
            </div>
            <!-- кнопки -->
            <div class="main__btn-box">
                <a href="page6.html" class="previous">&laquo; Назад</a>
                <a href="page8.html" class="next">Вперед &raquo;</a>
            </div>
            <div class="main__btn-box-o">
                <a href="page6.html" class="previous round">&#8249;</a>
                <a href="page8.html" class="next round">&#8250;</a>
            </div>
        </div>

        <button onclick="topFunction()" id="myBtn" title="Перейти к началу">вверх</button>

        <script async src="../script/js.js"></script>

        <!-- &lsaquo;&rsaquo;&lsaquo;/&rsaquo;
             &lsaquo;script&rsaquo;&lsaquo;/script&rsaquo; -->
        <!-- <details>
            <summary>Заголовок</summary>
            Здесь располагается скрытый контент, который будет отображен после клика по заголовку.
        </details>
    </div>
</body>

</html>